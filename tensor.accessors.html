<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Arraymancer - Module accessors</title>

  <link href="docutils.css" rel="stylesheet" type="text/css"/>
  <link href="nav.css" rel="stylesheet" type="text/css"/>

  <link href='http://fonts.googleapis.com/css?family=Raleway:400,600,900' rel='stylesheet' type='text/css'/>
  <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>
</head>
<body>
<a href="https://github.com/mratsim/arraymancer"><img style="position: fixed; top: 0; right: 0; border: 0; z-index: 10;" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a>
<header>
  <a class="pagetitle" href="index.html">Arraymancer</a>
  <span>
    <a href="#">Technical reference</a>
    <ul class="monospace">
      <span>
        <a href="#">Core tensor API</a>
        <ul class="monospace">
          <li><a href="tensor.accessors_macros_read.html">tensor.accessors_macros_read</a></li>
          <li><a href="tensor.accessors_macros_syntax.html">tensor.accessors_macros_syntax</a></li>
          <li><a href="tensor.accessors_macros_write.html">tensor.accessors_macros_write</a></li>
          <li><a href="tensor.accessors.html">tensor.accessors</a></li>
          <li><a href="tensor.aggregate.html">tensor.aggregate</a></li>
          <li><a href="tensor.comparison.html">tensor.comparison</a></li>
          <li><a href="tensor.data_structure.html">tensor.data_structure</a></li>
          <li><a href="tensor.display.html">tensor.display</a></li>
          <li><a href="tensor.exporting.html">tensor.exporting</a></li>
          <li><a href="tensor.filling_data.html">tensor.filling_data</a></li>
          <li><a href="tensor.higher_order_applymap.html">tensor.higher_order_applymap</a></li>
          <li><a href="tensor.higher_order_foldreduce.html">tensor.higher_order_foldreduce</a></li>
          <li><a href="tensor.init_cpu.html">tensor.init_cpu</a></li>
          <li><a href="tensor.init_copy_cpu.html">tensor.init_copy_cpu</a></li>
          <li><a href="tensor.lapack.html">tensor.lapack</a></li>
          <li><a href="tensor.math_functions.html">tensor.math_functions</a></li>
          <li><a href="tensor.operators_blas_l1.html">tensor.operators_blas_l1</a></li>
          <li><a href="tensor.operators_blas_l2l3.html">tensor.operators_blas_l2l3</a></li>
          <li><a href="tensor.operators_broadcasted.html">tensor.operators_broadcasted</a></li>
          <li><a href="tensor.operators_logical.html">tensor.operators_logical</a></li>
          <li><a href="tensor.optim_ops_fusion.html">tensor.optim_ops_fusion</a></li>
          <li><a href="tensor.shapeshifting.html">tensor.shapeshifting</a></li>
          <li><a href="tensor.syntactic_sugar.html">tensor.syntactic_sugar</a></li>
          <li><a href="tensor.ufunc.html">tensor.ufunc</a></li>
        </ul>
      </span>
      <span>
        <a href="#">Autograd</a>
        <ul class="monospace">
          <li><a href="ag.ag_accessors.html">Accessors</a></li>
          <li><a href="ag.ag_data_structure.html">Data structure</a></li>
          <li><a href="ag.gates_basic.html">Basic operations</a></li>
          <li><a href="ag.gates_blas.html">Linear algebra operations</a></li>
          <li><a href="ag.gates_reduce.html">Reduction operations</a></li>
        </ul>
      </span>
      <span>
        <a href="#">Neural network API</a>
        <ul class="monospace">
          <li><a href="nn_activation.relu.html">Activation: Relu (Rectified linear Unit)</a></li>
          <li><a href="nn_activation.sigmoid.html">Activation: Sigmoid</a></li>
          <li><a href="nn_layers.conv2D.html">Layers: Convolution</a></li>
          <li><a href="nn_layers.conv2D.html">Layers: Linear/Dense</a></li>
          <li><a href="nn_loss.sigmoid_cross_entropy.html">Loss: Sigmoid Cross-Entropy</a></li>
          <li><a href="nn_optimizers.optimizers.html">Optimizers</a></li>
        </ul>
      </span>
      <span>
        <a href="#">Neuralnet primitives</a>
        <ul class="monospace">
          <li><a href="nnp.nnp_activation.html">Activation</a></li>
          <li><a href="nnp.nnp_convolution.html">Convolution</a></li>
          <li><a href="nnp.nnp_linear.html">Linear / Dense layer</a></li>
          <li><a href="nnp.nnp_sigmoid_cross_entropy.html">Sigmoid Cross-Entropy loss</a></li>
          <li><a href="nnp.nnp_softmax_cross_entropy.html">Softmax Cross-Entropy loss</a></li>
        </ul>
      </span>
    </ul>
  </span>
  <span>
    <a href="#">Tutorial</a>
    <ul class="monospace">
      <li><a href="tuto.first_steps.html">First steps</a></li>
      <li><a href="tuto.slicing.html">Taking a slice of a tensor</a></li>
      <li><a href="tuto.linear_algebra.html">Matrix & vectors operations</a></li>
      <li><a href="tuto.broadcasting.html">Broadcasted operations</a></li>
      <li><a href="tuto.shapeshifting.html">Transposing, Reshaping, Permuting, Concatenating</a></li>
      <li><a href="tuto.map_reduce.html">Map & Reduce</a></li>
      <li><a href="tuto.iterators.html">Basic iterators</a></li>
    </ul>
  </span>
  <span>
    <a href="#">Spellbook (How-To&apos;s)</a>
    <ul class="monospace">
      <li><a href="howto.type_conversion.html">How to convert a Tensor type?</a></li>
      <li><a href="howto.ufunc.html">How to create a new universal function?</a></li>
      <li><a href="howto.perceptron.html">How to create a multilayer perceptron?</a></li>
    </ul>
  </span>
  <span>
    <a href="#">Under the hood</a>
    <ul class="monospace">
      <li><a href="uth.speed.html">How Arraymancer achieves its speed?</a></li>
      <li><a href="uth.copy_semantics.html">Why does `=` share data by default aka reference semantics?</a></li>
    </ul>
  </span>
</header>
<article id="documentId">
  <div class="container">
    <h1 class="title">Module accessors</h1>
    <div class="row">
  <div class="three columns">
  <div id="global-links">
    <ul class="simple">
    </ul>
  </div>
  <div id="searchInput">
    Search: <input type="text" id="searchInput"
      onkeyup="search()" />
  </div>
  <div>
    Group by:
    <select onchange="groupBy(this.value)">
      <option value="section">Section</option>
      <option value="type">Type</option>
    </select>
  </div>
  <ul class="simple simple-toc" id="toc-list">
<li>
  <a class="reference reference-toplevel" href="#6" id="56">Imports</a>
  <ul class="simple simple-toc-section">
    
  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#12" id="62">Procs</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#atContiguousIndex,Tensor[T],int"
    title="atContiguousIndex[T](t: Tensor[T]; idx: int): T"><wbr />at<wbr />Contiguous<wbr />Index<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#atContiguousIndex,Tensor[T],int_2"
    title="atContiguousIndex[T](t: var Tensor[T]; idx: int): var T"><wbr />at<wbr />Contiguous<wbr />Index<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#atAxisIndex,Tensor[T],int,int"
    title="atAxisIndex[T](t: Tensor[T]; axis, idx: int): Tensor[T]"><wbr />at<wbr />Axis<wbr />Index<span class="attachedType" style="visibility:hidden"></span></a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#15" id="65">Iterators</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#items.i,Tensor[T]"
    title="items[T](t: Tensor[T]): T"><wbr />items<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#items.i,Tensor[T],int,int"
    title="items[T](t: Tensor[T]; offset, size: int): T"><wbr />items<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#mitems.i,Tensor[T]"
    title="mitems[T](t: var Tensor[T]): var T"><wbr />mitems<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#mitems.i,Tensor[T],int,int"
    title="mitems[T](t: var Tensor[T]; offset, size: int): var T"><wbr />mitems<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#enumerate.i,Tensor[T]"
    title="enumerate[T](t: Tensor[T]): (int, T)"><wbr />enumerate<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#enumerate.i,Tensor[T],int,int"
    title="enumerate[T](t: Tensor[T]; offset, size: int): (int, T)"><wbr />enumerate<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#menumerate.i,Tensor[T]"
    title="menumerate[T](t: Tensor[T]): (int, var T)"><wbr />menumerate<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#menumerate.i,Tensor[T],int,int"
    title="menumerate[T](t: Tensor[T]; offset, size: int): (int, var T)"><wbr />menumerate<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#pairs.i,Tensor[T]"
    title="pairs[T](t: Tensor[T]): (seq[int], T)"><wbr />pairs<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#mpairs.i,Tensor[T]"
    title="mpairs[T](t: var Tensor[T]): (seq[int], var T)"><wbr />mpairs<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#zip.i,Tensor[T],Tensor[U]"
    title="zip[T, U](t1: Tensor[T]; t2: Tensor[U]): (T, U)"><wbr />zip<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#zip.i,Tensor[T],Tensor[U],int,int"
    title="zip[T, U](t1: Tensor[T]; t2: Tensor[U]; offset, size: int): (T, U)"><wbr />zip<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#zip.i,Tensor[T],Tensor[U],Tensor[V]"
    title="zip[T, U, V](t1: Tensor[T]; t2: Tensor[U]; t3: Tensor[V]): (T, U, V)"><wbr />zip<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#zip.i,Tensor[T],Tensor[U],Tensor[V],int,int"
    title="zip[T, U, V](t1: Tensor[T]; t2: Tensor[U]; t3: Tensor[V]; offset, size: int): (T, U, V)"><wbr />zip<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#mzip.i,Tensor[T],Tensor[U]"
    title="mzip[T, U](t1: var Tensor[T]; t2: Tensor[U]): (var T, U)"><wbr />mzip<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#mzip.i,Tensor[T],Tensor[U],int,int"
    title="mzip[T, U](t1: var Tensor[T]; t2: Tensor[U]; offset, size: int): (var T, U)"><wbr />mzip<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#mzip.i,Tensor[T],Tensor[U],Tensor[V]"
    title="mzip[T, U, V](t1: var Tensor[T]; t2: Tensor[U]; t3: Tensor[V]): (var T, U, V)"><wbr />mzip<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#mzip.i,Tensor[T],Tensor[U],Tensor[V],int,int"
    title="mzip[T, U, V](t1: var Tensor[T]; t2: Tensor[U]; t3: Tensor[V]; offset, size: int): (var T, U, V)"><wbr />mzip<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#enumerateZip.i,Tensor[T],Tensor[U]"
    title="enumerateZip[T, U](t1: Tensor[T]; t2: Tensor[U]): (int, T, U)"><wbr />enumerate<wbr />Zip<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#enumerateZip.i,Tensor[T],Tensor[U],int,int"
    title="enumerateZip[T, U](t1: Tensor[T]; t2: Tensor[U]; offset, size: int): (int, T, U)"><wbr />enumerate<wbr />Zip<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#enumerateZip.i,Tensor[T],Tensor[U],Tensor[V]"
    title="enumerateZip[T, U, V](t1: Tensor[T]; t2: Tensor[U]; t3: Tensor[V]): (int, T, U, V)"><wbr />enumerate<wbr />Zip<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#enumerateZip.i,Tensor[T],Tensor[U],Tensor[V],int,int"
    title="enumerateZip[T, U, V](t1: Tensor[T]; t2: Tensor[U]; t3: Tensor[V]; offset, size: int): (
    int, T, U, V)"><wbr />enumerate<wbr />Zip<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#menumerateZip.i,Tensor[T],Tensor[U]"
    title="menumerateZip[T, U](t1: var Tensor[T]; t2: Tensor[U]): (int, var T, U)"><wbr />menumerate<wbr />Zip<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#menumerateZip.i,Tensor[T],Tensor[U],int,int"
    title="menumerateZip[T, U](t1: var Tensor[T]; t2: Tensor[U]; offset, size: int): (int, var T, U)"><wbr />menumerate<wbr />Zip<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#axis.i,Tensor[T],int"
    title="axis[T](t: Tensor[T]; axis: int): Tensor[T]"><wbr />axis<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#axis.i,Tensor[T],int,int,int"
    title="axis[T](t: Tensor[T]; axis, offset, size: int): Tensor[T]"><wbr />axis<span class="attachedType" style="visibility:hidden"></span></a></li>
  <li><a class="reference" href="#zipAxis.i,Tensor[T],Tensor[U],int"
    title="zipAxis[T, U](a: Tensor[T]; b: Tensor[U]; axis: int): tuple[a: Tensor[T], b: Tensor[U]]"><wbr />zip<wbr />Axis<span class="attachedType" style="visibility:hidden"></span></a></li>

  </ul>
</li>

</ul>

  </div>
  <div class="nine columns" id="content">
  <div id="tocRoot"></div>
  <p class="module-desc"></p>
  <div class="section" id="6">
<h1><a class="toc-backref" href="#6">Imports</a></h1>
<dl class="item">
<a class="reference external" href="./private/p_accessors.html">./private/p_accessors</a>, <a class="reference external" href="./private/p_checks.html">./private/p_checks</a>, <a class="reference external" href="./data_structure.html">./data_structure</a>
</dl></div>
<div class="section" id="12">
<h1><a class="toc-backref" href="#12">Procs</a></h1>
<dl class="item">
<dt id="atContiguousIndex"><a name="atContiguousIndex,Tensor[T],int"></a><pre><span class="Keyword">proc</span> <span class="Identifier">atContiguousIndex</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">idx</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">T</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">noSideEffect</span><span class="Other">,</span> <span class="Identifier">inline</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
Return value of tensor at contiguous index i.e. as treat the tensor as flattened
&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L19"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L19" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="atContiguousIndex"><a name="atContiguousIndex,Tensor[T],int_2"></a><pre><span class="Keyword">proc</span> <span class="Identifier">atContiguousIndex</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t</span><span class="Other">:</span> <span class="Keyword">var</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">idx</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">var</span> <span class="Identifier">T</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">noSideEffect</span><span class="Other">,</span> <span class="Identifier">inline</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
Return value of tensor at contiguous index (mutable) i.e. as treat the tensor as flattened
&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L24"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L24" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="atAxisIndex"><a name="atAxisIndex,Tensor[T],int,int"></a><pre><span class="Keyword">proc</span> <span class="Identifier">atAxisIndex</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">axis</span><span class="Other">,</span> <span class="Identifier">idx</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">noInit</span><span class="Other">,</span> <span class="Identifier">inline</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
Returns a sliced tensor in the given axis index
&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L29"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L29" class="link-seesrc" target="_blank" >Edit</a>

</dd>

</dl></div>
<div class="section" id="15">
<h1><a class="toc-backref" href="#15">Iterators</a></h1>
<dl class="item">
<dt id="items"><a name="items.i,Tensor[T]"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">items</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">T</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<p>Inline iterator on Tensor values</p>
<p>The iterator will iterate in C order regardingless of the tensor properties (Fortran layout, non-contiguous, slice ...). So [0, 0, 0] then [0, 0, 1] then ... then [0, 1, 0] ...</p>
<dl class="docutils"><dt>Usage:</dt>
<dd><pre class="listing"><span class="Keyword">for</span> <span class="Identifier">val</span> <span class="Keyword">in</span> <span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Comment"># items is implicitly called</span>
  <span class="Identifier">val</span> <span class="Operator">+=</span> <span class="DecNumber">42</span></pre></dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L39"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L39" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="items"><a name="items.i,Tensor[T],int,int"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">items</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">offset</span><span class="Other">,</span> <span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">T</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
Inline iterator on Tensor values (with offset)
&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L51"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L51" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="mitems"><a name="mitems.i,Tensor[T]"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">mitems</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t</span><span class="Other">:</span> <span class="Keyword">var</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">var</span> <span class="Identifier">T</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<p>Inline iterator on Tensor values (mutable, with offset)</p>
<p>Note: due to C++ restrictions and Nim current codegen on mutable iterator, it is not possible to use this iterator with the C++ backend or at the same time as Cuda (that uses C++)</p>

&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L58"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L58" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="mitems"><a name="mitems.i,Tensor[T],int,int"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">mitems</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t</span><span class="Other">:</span> <span class="Keyword">var</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">offset</span><span class="Other">,</span> <span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">var</span> <span class="Identifier">T</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<p>Inline iterator on Tensor values (mutable, with offset)</p>
<p>Note: due to C++ restrictions and Nim current codegen on mutable iterator, it is not possible to use this iterator with the C++ backend or at the same time as Cuda (that uses C++)</p>

&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L66"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L66" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="enumerate"><a name="enumerate.i,Tensor[T]"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">enumerate</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span><span class="Identifier">int</span><span class="Other">,</span> <span class="Identifier">T</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
Enumerate Tensor values
&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L77"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L77" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="enumerate"><a name="enumerate.i,Tensor[T],int,int"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">enumerate</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">offset</span><span class="Other">,</span> <span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span><span class="Identifier">int</span><span class="Other">,</span> <span class="Identifier">T</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
Enumerate Tensor values (with offset)
&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L81"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L81" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="menumerate"><a name="menumerate.i,Tensor[T]"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">menumerate</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span><span class="Identifier">int</span><span class="Other">,</span> <span class="Keyword">var</span> <span class="Identifier">T</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<p>Enumerate Tensor values (mutable)</p>
<p>Note: due to C++ restrictions and Nim current codegen on mutable iterator, it is not possible to use this iterator with the C++ backend or at the same time as Cuda (that uses C++)</p>

&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L88"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L88" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="menumerate"><a name="menumerate.i,Tensor[T],int,int"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">menumerate</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">offset</span><span class="Other">,</span> <span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span><span class="Identifier">int</span><span class="Other">,</span> <span class="Keyword">var</span> <span class="Identifier">T</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span><span class="Other">,</span>
    <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<p>Enumerate Tensor values (mutable, with offset)</p>
<p>Note: due to C++ restrictions and Nim current codegen on mutable iterator, it is not possible to use this iterator with the C++ backend or at the same time as Cuda (that uses C++)</p>

&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L96"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L96" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="pairs"><a name="pairs.i,Tensor[T]"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">pairs</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span><span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">int</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">T</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<p>Inline iterator on Tensor (coordinates, values)</p>
<p>The iterator will iterate in C order regardingless of the tensor properties (Fortran layout, non-contiguous, slice ...). So [0, 0, 0] then [0, 0, 1] then ... then [0, 1, 0] ...</p>
<p>It returns a tuple of (coordinates, value) like (@[1,0,1], 1337)</p>
<dl class="docutils"><dt>Usage:</dt>
<dd><pre class="listing"><span class="Keyword">for</span> <span class="Identifier">coord</span><span class="Punctuation">,</span> <span class="Identifier">val</span> <span class="Keyword">in</span> <span class="Identifier">t</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">coord</span>
  <span class="Identifier">echo</span> <span class="Identifier">val</span></pre><pre class="listing"><span class="Keyword">for</span> <span class="Identifier">coordval</span> <span class="Keyword">in</span> <span class="Identifier">t</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">coordval</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Identifier">echo</span> <span class="Identifier">coordval</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span></pre></dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L107"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L107" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="mpairs"><a name="mpairs.i,Tensor[T]"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">mpairs</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t</span><span class="Other">:</span> <span class="Keyword">var</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span><span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">int</span><span class="Other">]</span><span class="Other">,</span> <span class="Keyword">var</span> <span class="Identifier">T</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<p>Inline iterator on Tensor (coordinates, values) (mutable)</p>
<p>Note: due to C++ restrictions and Nim current codegen on mutable iterator, it is not possible to use this iterator with the C++ backend or at the same time as Cuda (that uses C++)</p>

&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L126"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L126" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="zip"><a name="zip.i,Tensor[T],Tensor[U]"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">zip</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t1</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">t2</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">U</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span><span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
Iterates simultaneously on two tensors returning their elements in a tuple. Note: only tensors of the same shape will be zipped together.
&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L134"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L134" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="zip"><a name="zip.i,Tensor[T],Tensor[U],int,int"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">zip</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t1</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">t2</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">U</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">offset</span><span class="Other">,</span> <span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span><span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span><span class="Other">,</span>
    <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
Iterates simultaneously on two tensors returning their elements in a tuple. (with offset) Note: only tensors of the same shape will be zipped together.
&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L141"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L141" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="zip"><a name="zip.i,Tensor[T],Tensor[U],Tensor[V]"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">zip</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t1</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">t2</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">U</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">t3</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">V</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span><span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span><span class="Other">,</span>
    <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
Iterates simultaneously on two tensors returning their elements in a tuple. Note: only tensors of the same shape will be zipped together.
&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L150"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L150" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="zip"><a name="zip.i,Tensor[T],Tensor[U],Tensor[V],int,int"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">zip</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t1</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">t2</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">U</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">t3</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">V</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">offset</span><span class="Other">,</span> <span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span><span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">,</span>
    <span class="Identifier">V</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
Iterates simultaneously on two tensors returning their elements in a tuple. (with offset) Note: only tensors of the same shape will be zipped together.
&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L158"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L158" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="mzip"><a name="mzip.i,Tensor[T],Tensor[U]"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">mzip</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t1</span><span class="Other">:</span> <span class="Keyword">var</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">t2</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">U</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span><span class="Keyword">var</span> <span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<p>Iterates simultaneously on two tensors returning their elements in a tuple. (mutable) Note: only tensors of the same shape will be zipped together.</p>
<p>Note: due to C++ restrictions and Nim current codegen on mutable iterator, it is not possible to use this iterator with the C++ backend or at the same time as Cuda (that uses C++)</p>

&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L168"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L168" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="mzip"><a name="mzip.i,Tensor[T],Tensor[U],int,int"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">mzip</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t1</span><span class="Other">:</span> <span class="Keyword">var</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">t2</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">U</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">offset</span><span class="Other">,</span> <span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span><span class="Keyword">var</span> <span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma">
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<p>Iterates simultaneously on two tensors returning their elements in a tuple. (mutable, with offset) Note: only tensors of the same shape will be zipped together.</p>
<p>Note: due to C++ restrictions and Nim current codegen on mutable iterator, it is not possible to use this iterator with the C++ backend or at the same time as Cuda (that uses C++)</p>

&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L179"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L179" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="mzip"><a name="mzip.i,Tensor[T],Tensor[U],Tensor[V]"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">mzip</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t1</span><span class="Other">:</span> <span class="Keyword">var</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">t2</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">U</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">t3</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">V</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span><span class="Keyword">var</span> <span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma">
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<p>Iterates simultaneously on two tensors returning their elements in a tuple. (mutable) Note: only tensors of the same shape will be zipped together.</p>
<p>Note: due to C++ restrictions and Nim current codegen on mutable iterator, it is not possible to use this iterator with the C++ backend or at the same time as Cuda (that uses C++)</p>

&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L192"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L192" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="mzip"><a name="mzip.i,Tensor[T],Tensor[U],Tensor[V],int,int"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">mzip</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t1</span><span class="Other">:</span> <span class="Keyword">var</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">t2</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">U</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">t3</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">V</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">offset</span><span class="Other">,</span> <span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span>
    <span class="Keyword">var</span> <span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<p>Iterates simultaneously on two tensors returning their elements in a tuple. (mutable, with offset) Note: only tensors of the same shape will be zipped together.</p>
<p>Note: due to C++ restrictions and Nim current codegen on mutable iterator, it is not possible to use this iterator with the C++ backend or at the same time as Cuda (that uses C++)</p>

&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L203"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L203" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="enumerateZip"><a name="enumerateZip.i,Tensor[T],Tensor[U]"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">enumerateZip</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t1</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">t2</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">U</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span><span class="Identifier">int</span><span class="Other">,</span> <span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span><span class="Other">,</span>
    <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
Enumerate simultaneously on two tensors returning their elements in a tuple. Note: only tensors of the same shape will be zipped together.
&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L217"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L217" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="enumerateZip"><a name="enumerateZip.i,Tensor[T],Tensor[U],int,int"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">enumerateZip</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t1</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">t2</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">U</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">offset</span><span class="Other">,</span> <span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span><span class="Identifier">int</span><span class="Other">,</span> <span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma">
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
Enumerate simultaneously on two tensors returning their elements in a tuple. (with offset) Note: only tensors of the same shape will be zipped together.
&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L224"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L224" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="enumerateZip"><a name="enumerateZip.i,Tensor[T],Tensor[U],Tensor[V]"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">enumerateZip</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t1</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">t2</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">U</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">t3</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">V</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span><span class="Identifier">int</span><span class="Other">,</span> <span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma">
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
Enumerate simultaneously on two tensors returning their elements in a tuple. Note: only tensors of the same shape will be zipped together.
&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L233"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L233" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="enumerateZip"><a name="enumerateZip.i,Tensor[T],Tensor[U],Tensor[V],int,int"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">enumerateZip</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t1</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">t2</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">U</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">t3</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">V</span><span class="Other">]</span><span class="Other">;</span>
                            <span class="Identifier">offset</span><span class="Other">,</span> <span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span><span class="Identifier">int</span><span class="Other">,</span> <span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
Enumerate simultaneously on two tensors returning their elements in a tuple. (with offset) Note: only tensors of the same shape will be zipped together.
&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L241"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L241" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="menumerateZip"><a name="menumerateZip.i,Tensor[T],Tensor[U]"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">menumerateZip</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t1</span><span class="Other">:</span> <span class="Keyword">var</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">t2</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">U</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span><span class="Identifier">int</span><span class="Other">,</span> <span class="Keyword">var</span> <span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span><span class="Other">,</span>
    <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<p>Enumerate simultaneously on two tensors returning their elements in a tuple. (mutable) Note: only tensors of the same shape will be zipped together.</p>
<p>Note: due to C++ restrictions and Nim current codegen on mutable iterator, it is not possible to use this iterator with the C++ backend or at the same time as Cuda (that uses C++)</p>

&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L251"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L251" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="menumerateZip"><a name="menumerateZip.i,Tensor[T],Tensor[U],int,int"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">menumerateZip</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t1</span><span class="Other">:</span> <span class="Keyword">var</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">t2</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">U</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">offset</span><span class="Other">,</span> <span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span><span class="Identifier">int</span><span class="Other">,</span>
    <span class="Keyword">var</span> <span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">)</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">noSideEffect</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>
<p>Enumerate simultaneously on two tensors returning their elements in a tuple. (mutable, with offset) Note: only tensors of the same shape will be zipped together.</p>
<p>Note: due to C++ restrictions and Nim current codegen on mutable iterator, it is not possible to use this iterator with the C++ backend or at the same time as Cuda (that uses C++)</p>

&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L262"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L262" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="axis"><a name="axis.i,Tensor[T],int"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">axis</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">axis</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L325"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L325" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="axis"><a name="axis.i,Tensor[T],int,int,int"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">axis</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">t</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">axis</span><span class="Other">,</span> <span class="Identifier">offset</span><span class="Other">,</span> <span class="Identifier">size</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L328"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L328" class="link-seesrc" target="_blank" >Edit</a>

</dd>
<dt id="zipAxis"><a name="zipAxis.i,Tensor[T],Tensor[U],int"></a><pre><span class="Keyword">iterator</span> <span class="Identifier">zipAxis</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">U</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">axis</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">tuple</span><span class="Other">[</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Tensor</span><span class="Other">[</span><span class="Identifier">U</span><span class="Other">]</span><span class="Other">]</span> <span class="Other pragmabegin">{.</span><div class="pragma"><span class="Identifier">inline</span></div><span class="Other pragmaend">.}</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="https://github.com/mratsim/arraymancer/tree/master/src/tensor/accessors.nim#L331"
class="link-seesrc" target="_blank">Source</a>
<a href="https://github.com/mratsim/arraymancer/edit/master/src/tensor/accessors.nim#L331" class="link-seesrc" target="_blank" >Edit</a>

</dd>

</dl></div>

  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small>Made with Nim. Generated: 2017-12-13 23:30:19 UTC</small>
      </div>
    </div>
  </div>
</article>
</body>
</html>
